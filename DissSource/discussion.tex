\section{Discussion}
The following section reflects on the project requirements set out in section 3, and to what extent the system implemented complied with them. This section also discusses and critiques the overall approach of this project from choice of methodology, to design, to implementation and testing.

\subsection{Requirements Compliance}
All High priority functional requirements were implemented within the system. However, one Medium priority requirement was not achieved. This was FR12 which stated that users will be able to choose whether a graph is stored as Adjacency List or Adjacency Matrix before being coloured. This was intended to allow users to see how the computing complexity of the algorithm changes between the two storage methods. However, due to time constraints, the developer was not able to implement the RLF method of colouring an Adjacency Matrix graph and therefore could not implement this feature within the main program. However, whilst this feature would have been desirable, it only represented a Medium priority requirement and as such was not crucial to the aims of the project as a whole. It is, however, a feature to be added in the future. All non-functional requirements were satisfied within the final system. 

\subsection{System Critique}
The methodology chosen for this project (within section 3) was an agile approach allowing for quick movements between design, implementation and testing phases. However, as this project was mainly for the use of the developer, this was perhaps not the most effective choice. In fact, becoming tied into a specific methodology overall was perhaps not best suited to this type of project. Although breaking down the project into parts proved to be very useful, it does require a great initial time cost that can cause problems when the timeline of the project is rather short. With all that being said, it did mean that the overall design of the system was perhaps less wasteful than if no methodology was employed. Furthermore, it required the developer to think about how the program can be used, providing a system that can be used by other users. 
\\\\
The design of the system mainly focused on breaking up the components into distinct sections that could be easily understood and used independently of one another. Overall, the design proved very effective in being able to implement interfaces that abstract the implementation away from any users. Furthermore, it was able to take advantage of the Java language using the Comparable interface to make certain heuristics (such as those found in DSATUR) much easier to understand and implement. In addition, the encapsulation of Graphs into a construct of Vertex and Edge objects allowed for a good bridge of understanding between how a human understands a graph and what the computer can manipulate. This seemed more advantageous, to the developer, than the techniques of using integer arrays employed in many other projects. There are areas for improvement in the design of the main program, with more attention required to enhancing the user experience. 
\\\\
While the implementation stage was mostly smooth, some of the algorithms proved tricky to implement. It required multiple revisions in some cases, particularly in the case of DSATUR and RLF, and also some tweaks in design. The choice of Java for implementation proved to be a valid choice, as the developer was most comfortable in this language. This allowed for a mostly streamlined implementation phase. Due to the knowledge of the language the implementation was not held up by learning specifics of the language and most time was devoted to understanding the algorithms themselves. Due to time constraints, the implementation of the method for colouring an Adjacency Matrix graph using RLF was not able to be implemented. This was unfortunate as it meant that general comparisons of the algorithms when using Adjacency List and Adjacency Matrix could not be made. However, this is perhaps a good feature to add for the future. 
\\\\
The system testing was perhaps the weakest aspect of this project. Due to time constraints, the developer was not able to implement formal unit testing for the methods implemented. This means that there is no assurance that there are not bugs within the system. Although it can never be assured that no bugs are present within a system, formal testing would have increased confidence that the likely presence of bugs was minimal. The testing methods, as mentioned in section 3.4, were sufficient and appropriate given the time constraints. However, designing and implementing formal unit tests for each method would have perhaps proved a more effective testing approach. 
\\\\
Overall, the system as a whole did meet many of the aims and objectives set out within section 1, with the one objective not met (thorough testing) discussed above. The system, whilst being fully functional and satisfying the requirements of this project, is rather simplistic and there are areas for improvements. For example, more algorithms could be implemented using more cutting edge techniques such as that of the HillClimber, TabuCol, BacktrackingDSATUR, AntCol and more \cite{LEWISHillClimber, LewisR.M.R2015AGtG, LEWIS20121933}. Furthermore, the UI could be improved by making a GUI and perhaps some visual animations of the algorithms finding solutions in real time. 

